---
title: "Знакомство с Qt 2D графикой"
preview: "img/small/mmz02.png"
---

Следуйте инструкциям. В конце выполните задание, указанное в тексте.

## Окно с нарисованным кругом на Qt

>Основано на примере [Raster Window Example](http://doc.qt.io/qt-5/qtgui-rasterwindow-example.html)

### Создание проекта

### Файл main.cpp

Создайте файл "main.cpp", если он не создан, и поместите в него функцию main. Для удобства предлагаемый пример подробно прокомментирован &mdash; вам нужно переписать код, не переписывая комментарии:

```cpp
// Подключаем модуль QtGui целиком одним заголовком.
#include <QtGui/QtGui>

// Объявляем функцию main, принимающую аргументы командной строки в параметрах argc и argv
int main(int argc, char *argv[])
{
    // Объявляем переменную app типа QGuiApplication.
    // Объявить её надо как можно раньше, так как при инициализации Q*Application
    //  неявно инициализируются различные подсистемы Qt
    QGuiApplication app(argc, argv);

    // Объявляем переменную window типа QWindow.
    // Эта переменная представляет окно операционной системы.
    QWindow window;

    // Инициируем показ окна: показ случится позже, когда начнётся цикл событий
    window.show();

    // Запускаем цикл событий &mdash; метод exec выполняется вплоть до завершения
    //  работы приложения, и возвращает в main код возврата (ненулевой в случае ошибки).
    return app.exec();
}
```

### Заменяем обычный QWindow на RasterWindow

Обычный класс QWindow не содержит кода рисования круга &mdash; он вообще ничего не рисует. В Qt в таких случаях принято наследоваться от класса QWindow, реализуя свой класс окна. Так мы и сделаем: создайте файл "RasterWindow.h" и поместите в него код, описанный ниже, избегая комментариев:

```cpp
#pragma once
#include <QtGui/QtGui>

// Класс RasterWindow наследует все поля и методы класса QWindow
class RasterWindow : public QWindow
{
    // Макрос Q_OBJECT является меткой для Qt moc - генератора кода в составе Qt SDK
    Q_OBJECT

public: // Начало секции публично доступных полей и методов

    // Конструктор класса: принимает один (опциональный) параметр типа QWindow,
    //  в этом параметре можно передать родительское окно (например, для модального диалога)
    explicit RasterWindow(QWindow *parent = 0);

protected: // Начало секции полей и методов, доступных только в наследниках этого класса

    // Ниже перегружены полиморфные методы родительского класса QWindow
    // Библиотека Qt рассылает различные события по этим методам
    //  - метод event вызывается перед обработкой любых событий, включая resizeEvent и exposeEvent
    //  - метод resizeEvent вызывается при изменении размера окна
    //  - метод exposeEvent вызывается при показе окна
    bool event(QEvent *event) override;
    void resizeEvent(QResizeEvent *event) override;
    void exposeEvent(QExposeEvent *event) override;

private: // Начало секции полей и методов, доступных только в наследниках этого класса

    void renderLater();
    void renderNow();
    void render(QPainter *painter);

    // Класс QBackingStore предоставляет окну буфер рисования кадра.
    // Грубо говоря, этот буфер содержит будущие пиксели окна и позволяет
    //  рисовать векторную графику (фигуры, изображения, текст), заполняя
    //  этот буфер пикселей.
    QBackingStore *m_backingStore = nullptr;
};
```

Теперь создайте файл "RasterWindow.cpp". Прежде всего, в этот файл надо добавить заголовок "RasterWindow.h". Но кроме написанного нами заголовка есть ещё один файл, который будет создан при сборке программы инструментом [Qt moc](http://doc.qt.io/qt-5/why-moc.html). Мы должны подключить оба файла:

```cpp
#include "RasterWindow.h"
#include "moc_RasterWindow.cpp"
```

>Возможно, вас смутит, что мы включаем cpp файл в другой cpp файл. Схема компиляции C++ это не запрещает: директива `#include` во время сборки виртуально заменяется на содержимое указанного файла, то есть мы просто объединяем два файла в один. Можно было бы собирать каждый из них, но это требует добавления moc-файла в проект. Пока что мы не будем усложнять процесс сборки

Реализуем в файле "RasterWindow.cpp" конструктор класса. Перепишите этот код (кроме комментария):

```cpp
// В конструкторе создадим в динамической памяти новый объект QBackingStore.
// В современном C++ не принято использовать "new", но пока вы работаете с Qt,
//  "new" - это норма, т.к. Qt использует особый механизм управления памятью
//  parent-child.
// Именно поэтому мы передали "this" в конструктор QBackingStore.
// Объект класса RasterWindow становится родителем объекта класса QBackingStore.
// Когда будет вызван деструктор RasterWindow, Qt удалит и все дочерние объекты.
RasterWindow::RasterWindow(QWindow *parent)
    : QWindow(parent)
    , m_backingStore(new QBackingStore(this))
{
    setGeometry(100, 100, 800, 600);
}
```

Опишем метод event: этот метод вызывается при каждом событии окна, поэтому при его написании следует действовать аккуратно

* если мы не обработали событие, мы должны вызвать метод родительского класса: `QWindow::event(event)`, иначе механизм обработки событий Qt будет сломан
* мы должны обработать только событие UpdateRequest, которое уведомляет о запросе на изменение окна
    * изменение размера должно приводить к перерисовке окна

```cpp
bool RasterWindow::event(QEvent *event)
{
    if (event->type() == QEvent::UpdateRequest) {
        renderNow();
        return true;
    }
    return QWindow::event(event);
}
```

Опишем метод exposeEvent: этот метод класса QWindow библиотека Qt вызывает при фактическом показе окна.

```cpp
void RasterWindow::exposeEvent(QExposeEvent *)
{
    if (isExposed())
    {
        renderNow();
    }
}
```

Опишем метод resizeEvent: этот метод класса QWindow библиотека Qt вызывает при изменении размера окна.

```cpp
void RasterWindow::resizeEvent(QResizeEvent *resizeEvent)
{
    // Изменяем размер буфера кадра, чтобы он совпадал с размером окна
    m_backingStore->resize(resizeEvent->size());
    if (isExposed())
    {
        renderNow();
    }
}
```

Метод "renderLater" будет добавлять в очередь событий Qt событие обновления экрана (UpdateRequest), тем самым форсируя перерисовку кадра в ближайшем будущем.

```cpp
void RasterWindow::renderLater()
{
    requestUpdate();
}
```

Теперь реализуем самый сложный метод класса &mdash; renderNow. Метод будет запускать рисование на буфере кадра, очищать буфер, а потом готовый буфер выводить на экран. 

Вывод сначала в буфер, а затем в окно &mdash; это способ борьбы с мерцанием (flickering) изображения. Представьте, что мы будем рисовать сразу в окне, при этом операционная система будет рисовать содержимое дисплея с частотой 60Гц, а наша программа по каким-то причинам будет рисовать каждый кадр вчетверо дольше. Тогда на экране окажутся недорисованные фрагменты картинки:

![Иллюстрация](img/os/flickering.gif)

Чтобы избежать этого, мы будем рисовать во вспомогательный буфер. Чтобы убрать следы старого кадра, будем заливать буфер белым цветом путём вызова `painter.fillRect`. Перепишите код, предложенный ниже:

```cpp
void RasterWindow::renderNow()
{
    if (!isExposed())
    {
        return;
    }

    QRect rect(0, 0, width(), height());
    m_backingStore->beginPaint(rect);

    QPaintDevice *device = m_backingStore->paintDevice();
    QPainter painter(device);

    painter.fillRect(0, 0, width(), height(), Qt::white);
    render(&painter);
    painter.end();

    m_backingStore->endPaint();
    m_backingStore->flush(rect);
}
```

Остался всего один метод, и он будет простым: "render" устанавливает кисть рисования и рисует эллипс

```cpp
void RasterWindow::render(QPainter *painter)
{
    // Устанавливаем режим устранения ступенчатости фигур (anti-aliasing mode)
    painter->setRenderHint(QPainter::Antialiasing);

    // Устанавливаем кисть жёлтого цвета (цвет задан в RGB)
    painter->setBrush(QBrush(QColor(0xFA, 0xFE, 0x78)));

    // Рисуем эллипс на всё окно с отступом 5 пикселей
    painter->drawEllipse(QRect(5, 5, width() - 10, height() - 10));
}
```

Теперь перейдите в функцию main и замените тип переменной "window" с QWindow на RasterWindow. Не забудьте подключить заголовок "RasterWindow.h" в файле "main.cpp".

Соберите программу, запусти её. Убедитесь, что окно программы выглядит примерно так:

![Скриншот](img/2d/00_rasterwindow_static.png)

Вопросы для самопроверки:

* Что такое кисть (brush, в Qt - QBrush), зачем она нужна?
* Что такое перо (pen, в Qt - QPen), зачем оно нужно?
* Как изменится изображение, если не устанавливать режим anti-aliasing? (Вы можете попробовать это сделать и посмотреть)

### Исследуем программу в отладчике

**Остановитесь и проверьте следующее**

* код с предыдущих этапов у вас работает
* все ваши товарищи закончили те же этапы

После этого вместе с преподавателем посмотрите, как с помощью отладчика проинспектировать работу программы. Ответьте на вопросы:

* почему exposeEvent вызывается уже после вызова `window.show()`?
* почему при запуске программы вызывается resizeEvent?
* что показывает call stack, что такое стек и как стек используется для вызов функций?
* где находятся локальные переменные в памяти программы и как посмотреть их в отладчике?

## Добавляем анимацию

Наша следующая цель &mdash; добавить в окно анимацию движения шарика.

### Теоретический минимум: цикл рисования и обработки событий

В любой операционной системе оконные приложения рисуют содержимое окон непрерывно и циклически. В каждую секунду в системе происходит множество событий:

- мониторы обновляются с частотой ~60 Герц (60 кадров в секунду)
- контроллер мыши присылает уведомления об изменении положения мыши
- контроллер клавиатуры присылает состояние клавиш
- каждая программа старается получить процессорное время, чтобы выполнить свои задачи

В таких условиях операционной системе (ОС) приходится ловко манипулировать множеством событий и потоков данных. Например, 60 раз в секунду система собирает изображения всех окон, рисует их поверх друг друга в одну картинку рабочего стола и выводит на экран.

Чтобы ОС могла выполнить свою задачу, программа должна ей помогать: вести общение с системой в режиме интерактивного диалога, реагируя на переданные окну события ввода и рисуя новые кадры со скоростью до ~60 кадров в секунду.

Графические библиотеки делают это путём реализации цикла событий (event loop). Qt также реализует цикл событий, запуск которого происходит внутри метода `QGuiApplication::exec()`. Мы можем встраивать свои действия в этот цикл событий путём отправки событий.

Однако, по умолчанию Qt старается сэкономить ресурсы и рисовать как можно реже. Чтобы реализовать анимацию, нам потребуется форсировать постоянное рисование новых кадров с частотой до 60 кадров в секунду.

### Добавляем окну свойство animating

Добавьте в класс RasterWindow новые публичные методы "isAnimating" и "setAnimating":

```cpp
bool isAnimating() const;
void setAnimating(bool isAnimating);
```

Затем добавьте булево поле для хранения данных этого свойства

```cpp
bool m_isAnimating = false;
```

>Мы используем термины "поле класса" и "свойство класса". Разница между ними в том, что термин "поле" выражает хранение данных в области памяти класса, а термин "свойство" выражает наблюдаемое извне свойство объекта. Свойство может быть реализовано с помощью поля, а может быть вычислено на лету: например, мы можем вычислить площадь прямоугольника, а не хранить её постоянно, если мы знаем ширину и высоту прямоугольника. Если у класса `Rectangle` есть метод `area()`, то внешний наблюдатель не заметит разницы между хранением поля и повторным вычислением. Поэтому "свойство" и "поле" &mdash; это разные вещи.

Реализация методов будет простой, единственный нюанс заключается в планировании (scheduling) выполнения метода render путём вызова метода renderLater:

```cpp
bool RasterWindow::isAnimating() const
{
    return m_isAnimating;
}

void RasterWindow::setAnimating(bool isAnimating)
{
    m_isAnimating = isAnimating;
    if (isAnimating)
    {
        renderLater();
    }
}
```

Самый важный трюк мы разместим в методе "renderNow". Если окно зациклено на анимацию, то после рисования кадра мы должны нарисовать новый кадр. Делать это немедленно нельзя: мы уйдём в бесконечную рекурсию, что приведёт к переполнению стека программы.

Поэтому мы будем лишь планировать перерисовку путём добавления события в очередь события. Фактически перерисовка состоится тогда, когда на то будет воля Qt. Тем не менее, мы расчитываем на частоту порядка 60Гц (благодаря вертикальной синхронизации и её обработке в Qt).

Перейдите к методу "RasterWindow::renderNow()" и добавьте в конец метода планирование перерисовки:

```cpp
if (m_isAnimating)
{
    renderLater();
}
```

Перейдите в функцию main и добавьте вызов метода setAnimating:

```cpp
    RasterWindow window;
    window.setAnimating(true);
    window.show();
```

Соберите программу и запустите. Не видите анимации? Ну конечно, ведь её же нет!

### Добавляем класс сцены и анимацию шарика

Чтобы анимировать шарик, надо на каждом кадре изменять его местоположение. Для этого надо как минимум где-то хранить позицию шарика.

Добавлять позицию шарика в поле класса RasterWindow не стоит: во-первых класс и так стал объёмным, во-вторых хранение позиции шарика явно выбивается из абстракции, которую задаёт термин "окно".

>Каждый класс реализует один слой абстракции. Каждая функция реализует одно действие на одном слое абстракции. Если вы чувствуете, что пишете в одной функции код с разных слоёв абстракции &mdash; значит, пора выделить новую функцию. Если вы хотите добавить в класс поле или метод с другого уровня абстракции &mdash; возможно, пора выделить новый класс

Создайте файлы "PoolTableScene.h" и "PoolTableScene.cpp". В новом заголовке поместите объявление класса PoolTableScene. На этот раз комментарий лучше сохранить, т.к. он отражает предназначение класса:

```cpp
#pragma once

#include <QtGui/QtGui>

// Класс PoolTableScene реализует сцену бильярдного стола, с шариками, стенками и фоном.
class PoolTableScene
{
    Q_OBJECT
public:
    PoolTableScene();

public slots: // Начало специальной секции публичных слотов (специфично для Qt)
    void update(float deltaSeconds);
    void redraw(QPainter& painter);

private:
    float m_ballPositionX = 0;
    float m_ballPositionY = 0;
};
```

Реализация PoolTableScene имеет всего три нюанса

* мы используем constexpr для определения констант
* мы используем анонимные пространства имён, чтобы при компоновке с другими файлами исходного кода не возникало конфликтов имён
    * т.е. другой файл в большой программе тоже может содержать константу BALL_SIZE, но с другим значением

```cpp
#include "PoolTableScene.h"
#include "moc_PoolTableScene.cpp"

namespace
{
// Скорость, пикселей в секунду
constexpr float BALL_SPEED_X = 50;
constexpr float BALL_SPEED_Y = 60;
constexpr float BALL_SIZE = 40;
}

PoolTableScene::PoolTableScene(QObject* parent = nullptr)
    : QObject(parent)
{
}

void PoolTableScene::update(float deltaSeconds)
{
    m_ballPositionX += BALL_SPEED_X;
    m_ballPositionY += BALL_SPEED_Y;
}

void PoolTableScene::redraw(QPainter& painter)
{
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setBrush(QBrush(QColor(0xFA, 0xFE, 0x78)));
    painter.drawEllipse(QRectF(m_ballPositionX, m_ballPositionY, BALL_SIZE, BALL_SIZE));
}
```

### Связываем классы окна и сцены

В языке C++ работает идиома владения: каждым объектом должен кто-то владеть &mdash; либо другой объект, либо какая-то фукнция.

* если объектом уникально владеет другой объект, то объект-хозяин должен создавать этот объект и удалять его самостоятельно
    * удаление должно произойти в любом варианте удаления хозяина: нельзя расчитывать, что перед удалением хозяина будет вызван какой-либо метод, кроме деструктора
* если объектом уникально владеет функция, она должна гарантировать, что объект будет создан перед использованием и удалён при выходе из функции или даже раньше
    * удаление должно произойти даже при выбросе исключения

В Qt соблюсти эти принципы позволяет идиома parent-child. В современном C++ без Qt для той же цели служит класс "unique_ptr" и функция "make_unique".

Итак, добавьте перед определением класса RasterWindow предварительное объявление класса (class pre-declaration) PoolTableScene:

```cpp
class PoolTableScene;

// Класс RasterWindow наследует все поля и методы класса QWindow
class RasterWindow : public QWindow
{
    // ...
```

Затем добавьте в класс RasterWindow поле `PoolTableScene *m_scene = nullptr;`



### Используем векторную алгебру

>Класс Vector2f вы можете взять из репозитория [dive-into-cpp](https://github.com/ps-group/dive-into-cpp). Скопируйте к себе в проект заголовок этого класса.

Векторная алгебра позволяет писать код выразительнее: вместо раздельных расчётов для каждой координаты вы можете складывать, умножать или обрабатывать иным путём две координаты в 2D пространстве, 3 координаты в 3D и 4 координаты в однородном представлении в 3D графике. Кроме того, современные процессоры и видеокарты (особенно видеокарты) получают ускорение за счёт использования векторных операций и векторизации. Впрочем, о векторизации вашего кода позаботится компилятор (если сможет), а вам нужно заботиться о выразительности кода.

Перепишите код в PoolTableScene, чтобы вместо float использовалась структура "Vector2f".

### Создаём приложение с event loop

### Добавляем движение

### Воспользуемся векторной алгеброй

### Добавляем отталкивание от стенок

Чтобы шар отталкивался от стенок, мы добавим серию проверок через if. 

## Численный метод против аналитического

### Волновое движение

### Задание sfml2.1: волновое движение с отталкиванием


Выполните задания, соблюдая [стиль кодирования](cxx_coding_style). Готовые задания должны быть выложены на [github](github.com).

## Задание workshop2.1

Напишите программу, в которой несколько разноцветных шаров летают в пределах окна, отталкиваясь от стенок

- шарам не нужно сталкиваться между собой
- цвета и начальные скорости шаров задаются прямо в коде без какого-либо механизма случайностей
- для выполнения задания вы можете использовать массив либо `std::vector`
- скорость и CircleShape шара лучше поместить в структуру, и использовать массив структур

Перед выполнением задачи изучите статью [Массивы в C++](/cxx/cxx_arrays). Вы можете использовать инициализацию массива при объявлении, чтобы сделать код более аккуратным и читаемым.

![Иллюстрация](img/labor/multiple_balls.png)

## Задание workshop2.2 (до 2 баллов)

Добавьте шарам возможность отталкиваться друг от друга.

Для обнаружения столкновений достаточно сравнить все возможные пары шаров: если расстояние между центрами меньше суммы радиусов, шары сталкиваются. Перебрать каждую пару объектов ровно один раз можно с помощью вложенного цикла:

```cpp
constexpr size_t SIZE = 100;
Ball balls[SIZE];

// Перебираем каждую пару объектов
//  - ни одну пару не используем дважды
//  - не используем пары из одного объекта (т.е. объект не сталкивается сам с собой)
for (size_t fi = 0; fi < SIZE; ++fi)
{
    for (size_t si = fi + 1; si < SIZE; ++si)
    {
        // проверяем столкновение fi, si
    }
}
```

Такой цикл среди всех возможных сочетаний элементов переберёт только пары разных элементов, и ни одну пару не переберёт дважды:

![Иллюстрация](img/labor/for-each-pair.png)

При расчёте скоростей после удара важны скорости шаров до удара и взаимное положение их центров (при условии, что массы шаров равны). Это проиллюстрировано рисунке:

![Иллюстрация](img/labor/balls_collision.gif)

Считайте, что шары имеют одинаковую массу, а столкновение абсолютно упругое. В этом случае скорости шаров после удара вычисляются так, как показано на схеме:

![Схема](img/labor/balls_collision.png)

### Как понять, что всё работает правильно

Достаточно проверить соблюдение основных закономерностей. Для удобства вы можете снять видеозапись экрана и оценивать работу столкновений на ней.

 1. Закон сохранения импульса в векторной форме должен сохраняться
    - проверьте, что суммарный вектор скорости до столкновения равен (с погрешностью 0.01) суммарному вектору скоростей после столкновения
 2. Суммарная кинетическая энергия шаров в системе должна оставаться неизменной; если скорости шариков нарастают или падают, значит, вы делаете что-то неправильно.

## Задание workshop2.3

Перед выполнением задачи изучите статью [Генерация случайных чисел в Modern C++](/cxx/cxx_random).

Добавьте случайную генерацию скоростей для шаров. Скорости не должны быть слишком большими или слишком маленькими: при генерации случайных чисел надо задать разумные ограничения.

## Задание workshop2.4 (дополнительное, до 2 баллов)

Изучите документацию класса [sf::Color](https://www.sfml-dev.org/documentation/2.4.2/classsf_1_1Color.php).

Затем добавьте случайную генерацию цвета шаров. Выбирать случайный цвет можно, например, следующим методом:

 1. Создать массив предопределённых значений типа sf::Color (достаточно 8 цветов на ваш вкус), этот массив будет служить палитрой
 2. Реализовать случайную генерацию индекса в этом массиве
 3. Получив случайный индекс, запросить из палитры цвет с этим индексом

>Составить хорошую палитру поможет сайт [websafecolors.info](http://websafecolors.info/).

Задание оценивается вполовину, если вы лишь берёте цвет из палитры. Для получения полных баллов надо повысить случайность цвета:

- выбирать два случайных индекса вместо одного
- полученные из палитры два цвета комбинировать путём вычисления среднего арифметического их RGBA-значений

## Задание workshop2.5 (дополнительное, до 2 баллов)

Добавьте возможность создавать шар со случайным цветом и скоростью по клику левой кнопкой мыши.

- шар не должен создаваться, если после создания он бы сразу пересёкся с другим шаром (другими словами, нельзя создать шар над другим шаром)
- для хранения динамического массива шаров вам не подойдёт массив в стиле `Ball balls[...]`, используйте `std::vector`

## Задание workshop2.6 (дополнительное, до 2 баллов)

Добавьте шарикам время жизни: каждый шар после создания существует ровно 10 секунд, после чего исчезает.

- счётчик оставшегося времени жизни лучше держать в структуре Ball
- удаление отживших своё элементов массива шаров можно выполнять с помощью идиомы `remove_if + erase`; изучите, как эта идиома реализуется в C++, и используйте её
- удаление отживших своё элементов удобнее выделить в функцию removeDeathBalls, обновление времени жизни всех шаров удобно выделить в функцию updateBallLifetimes

Если вы допускаете существенные ошибки в реализации `remove_if + erase`, то задание оценивается вполовину.

>Хорошая статья: [C++ std::remove_if with lambda explained](https://studiofreya.com/cpp/std-remove_if-with-lambda/)

## Задание workshop2.7 (дополнительное)

Могут возникать ситуации, когда шарики под воздействием других шариков "заталкиваются" друг в друга:

![Скриншот](img/labor/balls_endless_collision.jpg)

Причина проста: длительность кадров различается, и если один кадр длился долго, то шарики могли достаточно глубоко пересечься, прежде чем их столкновение будет обработано. Обработка столкновения приведёт к тому, что скорости шариков окажутся направлены в разные стороны. На следующем кадре они не успеют полностью разойтись, и программа решит, что произошло новое столкновение. Скорости сменят направление, и шарики вновь полетят навстречу друг другу:

![Иллюстрация](img/labor/sticked_balls.png)

Решить эту проблему можно, если в процедуре update интервал каждого кадра разделить на 5-10 небольших интервалов, и на каждом из этих маленьких интервалов выполнять полный расчёт физики. Уменьшение временных интервалов при расчётах физики уменьшит вероятность заталкивания, т.к. за один интервал шарики будут передвигаться на меньшее расстояние.

>При таком решении производительность не пострадает: если у вас меньше 1000-10000 шариков, то рисование шариков всё равно будет занимать больше ресурсов процессора, чем расчёт физики. Только на большом числе шариков квадратичная сложность попарного перебора окажет заметное влияние.

## Задание workshop2.8 (дополнительное)

>Освоить работу с макросом [assert](http://en.cppreference.com/w/cpp/error/assert) вам поможет статья [Assert. Что это?](https://habrahabr.ru/post/141080/).

С помощью инструкции assert добавьте проверку соблюдения законов сохранения энергии и импульса при проверке столкновений:

- закон сохранения энергии (уравнение умножено на 2): `m1 * v1^2 + m2 * v2^2 = m1 * w1^2 + m2 * w2^2`
    - v1, v2 - скорости до столкновения
    - w1, w2 - скорости после столкновения
    - m1, m2 - массы шариков
- закон сохранения импульса: `m1 * v1 + m2 * v2 = m1 * w1 + m2 * w2`
- можно считать, что все массы равны константе либо вычисляются как произведение константы и `R^3`, где R - радиус шара

Проверка через assert должна выполняться после расчёта отталкивания очередной пары шариков.

Сравнивать числа с плавающей точкой через `==` не стоит: при вычислениях возможны погрешности, из-за которых ожидаемое и реальное значение будут равны лишь приблизительно. Для сравнения лучше проверить, что разница между числами не превышает `0.01`:

```cpp
#include <cmath>

bool areFuzzyEqual(float a, float b)
{
    constexpr float tolerance = 0.01f;
    const bool areEqual = (std::abs(a - b) < tolerance);

    return areEqual;
}
```

Однако, при проверке закона сохранения энергии может возникнуть проблема: если скорости будут достаточно велики, то разница между квадратами скоростей может превысить `0.01`. В этом случае разумно проверять относительную погрешность, а не абсолютную. С другой стороны, для чисел вблизи нуля относительная погрешность может быть большой даже в нормальной ситуации. Например, относительная погрешность между `0.00001` и `0` бесконечно велика. Поэтому лучше всего комбинировать расчёт относительной и абсолютной погрешностей.

Мы можем доработать функцию areFuzzyEqual, чтобы выбирать между относительной и абсолютной погрешностями в зависимости от величины чисел:

```cpp
#include <cmath>

// Сравнение с допустимой абсолютной погрешностью
bool areCloseAbsolute(float a, float b, float tolerance = 0.001f)
{
    return std::abs(a - b) < tolerance;
}

// Сравнение с допустимой относительной погрешностью
bool areCloseRelative(float a, float b, float tolerance = 0.001f)
{
    return std::abs((a - b) / b) < tolerance;
}

// Сравнение двух чисел с плавающей точкой с допустимой погрешностью 0.001
bool areFuzzyEqual(float a, float b)
{
    constexpr float tolerance = 0.001f;
    if (std::abs(b) > 1.f)
    {
        return areCloseRelative(a, b, tolerance);
    }
    return areCloseAbsolute(a, b, tolerance);
}
```
