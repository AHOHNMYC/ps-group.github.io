---
title: 'Работа с байтами в C++17 и OpenGL'
subtitle: 'На самом низком уровне любые данные пересылаются в виде байт. Иногда программист вынужден напрямую работать с байтовыми сдвигами, размерами и указателями. В статье показаны принципы обработки байт в C++17.'
---

## Арифметика указателей в C++

В C++ для указателей определены арифметические операции. Допустим, есть указатель на тип "T": `T*`. Тогда операции имеют следующий смысл:

- при добавлении к указателю целого числа к адресу добавляется это число, умноженное на размер типа T. Например, если размер типа T равен 16 байтам, то выражение `ptr + 3` вернёт адрес, на 48 байт больший, чем ptr
- вычитание целого числа из указателей работает аналогично
- вычитание однотипных указателей возвращает разницу между адресами, поделённую на размер типа T
- сложение двух указателей запрещено
- операторы инкремента "++" и декремента "--" соответственно добавляют к адресу и отнимают от адреса один размер типа T

Арифметика указателей позволяет, например, организовать цикл для перебора массива чисел без использования индексов:

```cpp
#include <iostream>

int main()
{
	int numbers = [ 2, -2, 17, 79, 31 ];

	// Получаем адреса элементов с индексами 1 и 3
	const int* begin = &numbers[1];
	const int* end = &numbers[3];
	for (const int* p = begin; p != end; ++p)
	{
		std::cerr << *p << std::endl;
	}
	// Выводит 3 числа: -2 17 79
}
```

В примере выше для получения адреса элемента массива использовался оператор доступа к элементу `[]`, а затем оператор взятия адреса `&`. Можно было просто добавить к `numbers` нужное число, поскольку в C и C++ идентификатор переменной массива одновременно является указателем на начало этого массива:

```cpp
// Получаем адреса элементов с индексами 1 и 3
int* begin = numbers + 1;
int* end = numbers + 3;
```

## Однообразная обработка массивов C и контейнера vector из STL

Контейнер `std::vector<T>` имеет метод `.size()` для получения размера, методы `.begin()` и `.end()` для получения итераторов, указывающих на начало и конец массива соответственно, и метод `.data()`, который возвращает указатель на первый элемент массива.

Массивы `T[]` языка C не являются полноценными объектами и не имеют методов. Однако, в STL есть свободные функции `std::size(array)`, `std::begin(array)`, `std::end(array)`, `std::data(array)`, которые работают аналогично одноимённым методам в vector, но могут принимать как vector, так и массив в стиле C:

```cpp
#include <iostream>
#include <utility>

int main()
{
	std::vector<int> numbersVector = { 2, 4, 8, 16 };
	int numbersArray[] = { 2, 4, 8, 16 };

	std::cout << "numbersVector size: " << std::size(numbersVector) << std::endl;
	std::cout << "numbersArray size: " << std::size(numbersArray) << std::endl;
}
```

Данный код дважды напечатает число 4, т.к. размеры обоих контейнеров равны 4.

## Тип данных std::byte

Для работы с отдельными байтами начиная с C++17 в заголовке `<utility>` появился тип `std::byte`. Ранее аналогичную роль играл 8-битный тип `uint8_t` из заголовка `<stdint.h>`. Размер обоих типов равен одному байту.

## Размер и смещения полей структуры

Допустим, есть структура Point, содержащая поля x и y. У нас есть массив из 5 точек: `Point p[5]`. Как из этого массива получить все смещения каждого из полей x? А каждого из полей "y"? Для этого есть оператор `sizeof` и стандартный макрос `offsetof`:

```cpp
#include <iostream>
#include <utility>

struct Point
{
	float x;
	float y;
};

// Константа хранит размер структуры Point в байтах.
constexpr size_t kPointStructSize = sizeof(Point);

// Константа хранит смещение от начала структуры Point до поля x.
constexpr size_t kPointYOffset = offsetof(Point, x);

// Константа хранит смещение от начала структуры Point до поля y.
constexpr size_t kPointYOffset = offsetof(Point, y);
```

Можно, конечно, построить код на предположениях. Предположим, что размер `float` равен 4 байтам. Допустим, что размер структуры Point равен 8. Тогда смещения можно было бы вычислить таким методом:

```cpp
	// !ДУРНОЙ КОД - ТОЛЬКО ДЛЯ ПРИМЕРА!
#include <iostream>
#include <utility>

struct Point
{
	float x;
	float y;
};

int main()
{
	// !ДУРНОЙ КОД - ТОЛЬКО ДЛЯ ПРИМЕРА!
	Point points[5] = { { 1, 2 }, { 2, 3 }, { 5, 10 }, { 8, 2 }, {7, 4 } };
	const std::byte* begin = reinterpret_cast<const std::byte*>(points);
	const std::byte* end = begin + (8 * 5);
	for (const std::byte *p = begin + 4; p != end; p += 8)
	{
		const float* y = reinterpret_cast<const float*>(p);
		std::cerr << *y << std::endl;
	}
}
```

Однако, предполагать размер структуры или поля нельзя, потому что:

- стандарт C++ не гарантирует, что размер `float` равен 4 байтам
- компилятор имеет право вставлять между полями в структуре промежутки

Например, промежуток скорее всего появится в следующей структуре между полями `hasImagine` и `imagine`:

```cpp
struct Complex
{
	float real;
	bool hasImagine;
	float imagine;
};
```

Появление промежутка вызвано выравниванием всех полей структуры после поля типа `float` по границе 4 байта. Выравнивание применяется к полю `hasImagine`, так что после него, вероятно, будет 3 пустых байта. Такое выравнивание позволяет полям `real` и `imagine` одновременно иметь адрес, кратный числу 4. Кратность адреса числу 4 ускоряет доступ к памяти на многих вычислительных архитектурах.

## Interleaved arrays

Interleaved arrays — это комбинация нескольких массивов данных в одном массиве. По сути массив `Point points[10]` уже является interleaved arrays, поскольку в нём перемешаны величины координаты x для разных точек и величины координаты y.

Допустим, мы объявим структуру данных Vertex с полями position и color:

```cpp
struct Vertex
{
	vec2 position;
	vec4 color;
};
```

Массив структур Vertex можно интерпретировать как два "interleaved" массива: один содержит позиции вершин в виде пары (X, Y), другой — цвета в RGBA. Программисту удобно не хранить координаты и цвета отдельно, а смешивать их. Видеокарте при рисовании фигуры, определённой вершинами типа Vertex, разные величины потребуются в разное время: цвет потребуется только при вычислении цвета пикселя, а коодинаты нужны намного чаще.

Видеодрайверу всё равно, как именно программист хранит данные — ему важно знать, как получить доступ к каждому из подмассивов, скомбинированных в один массив. Вы можете и вовсе хранить каждую величину в отдельном массиве — но зачем, если OpenGL отлично умеет работать с interleaved arrays?

Функция [glVertexAttribPointer](http://docs.gl/gl3/glVertexAttribPointer) позволяет сообщить видеодрайверу, где искать величины внутри interleaved arrays.
