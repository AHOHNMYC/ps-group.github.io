---
title: 'Определяем версию ОС в языке C++'
---

Каждая операционная система имеет свой способ версионирования. Очевидно, что способ определения версии системы завязан на особенности конкретной ОС. Мы рассмотрим способы определения версии на Windows, Linux и Mac OS X.

Попутно мы освоим более важную вещь: работу с API операционных систем. API &mdash; это сокращение от Application Programming Interface. Каждая ОС предоставляет программисту низкоуровневые библиотеки, формирующие цельный интерфейс, позволяющий приложению реагировать на события ОС, либо делегировать ей свои задачи, а также общаться с другими процессами. Этот интерфейс и называется API операционной системы.

## Структура API ОС

По историческим причинам большинство API ОС предоставляет средства в процедурном стиле и на языке C89. Такие API состоят из функций, макросов-констант и структур, представляющих объекты системы.

API ОС принято оставлять неизменными на протяжении десятилетий, чтобы даже скомпилированные программы продолжали работать, и не нужно было править исходники или перекомпилировать их заново. Расплата за это &mdash; неудобный, построенный по старым стандартам интерфейс. Но эта проблема легко решается с помощью написания фасадов, предоставляющих более удобный и высокоуровневый интерфейс. Готовые фасады есть во многих программных библиотеках.

Обычно функции в составе API ОС реализованы в динамических библиотеках, то есть их адреса и реализации становятся известны только после запуска программы, что и позволяет использовать новые версии ОС без перекомпиляции предназначенных для неё программ.

Кроме функций API есть также вызовы ядра ОС, которые работают с помощью системных прерываний (т.е. требуют помощи процессора), а не на основе стека и прыжка по адресу функции. Вызов ядра &mdash; дорогая операция, потому что в процессе вызова процессор переходит из защищённого режима (userspace mode) в режим прямой работы с памятью и устройствами (kernel mode), а затем возвращается обратно в защищённый режим.

Вызовы ядра &mdash; это единственный способ попросить систему об операции, выходящей за полномочия процесса программы, например, о создании нового процесса. Есть разница в отношении к системным вызовам в мире UNIX и в мире Windows

- В UNIX-системах вызовы ядра доступны программисту напрямую, и считается нормальным их использовать
- В Windows вызовы ядра обычно начинаются с префикса "Rtl", и не рекомендуются для использования программистом. Для любой функции с префиксом "Rtl" есть замена в составе WinAPI (обычно это функция с тем же именем за вычетом префикса "Rtl").

Функции API ОС и вызовы ядра вместе называют вызовами API ОС. Эти вызовы лежат в основе множества операций по работе с файлами, устройствами и сетью, но стоят дороже обычного вызова функции в собственном коде программы.

## API для получения версии в Windows

Узнать версию операционной системы Windows можно с помощью WinAPI. WinAPI расшифровывается как Windows API. Он детально задокументирован на сайте [msdn.microsoft.com](https://msdn.microsoft.com/) &mdash; портале от компании Microsoft, предназначенном для сторонних разработчиков. Найти документацию по функциям WinAPI можно, передав в поисковик запрос "msdn FunctionName" или "FunctionName site:msdn.microsoft.com". Также помогают запросы из разряда "winapi how to ...".

Большая часть WinAPI доступна при подключении единственного заголовочного файла `Windows.h`. А это &mdash; небольшой пример:

```cpp
// Программа выводит строку
//   Running under Windows Major.Minor
// где Minor - старший кодовый номер версии,
//   а Major - младший кодовый номер версии

// В современном WinAPI функция GetVersion считается устаревшей,
//   поэтому пример годится лишь для демонстрации WinAPI.
int main()
{
    // Конструкция `::GetVersion()` указывает на вызов фукнции GetVersion
    //   из глобального пространства имён.
    const DWORD encodedVersion = ::GetVersion();
    const unsigned majorVersion = unsigned(LOBYTE(LOWORD(encodedVersion)));
    const unsigned minorVersion = unsigned(HIBYTE(LOWORD(encodedVersion)));

    std::printf("Running under Windows %u.%u\n", majorVersion, minorVersion);
}
```

Имейте ввиду, что функция GetVersion возвращает кодовый номер версии, который нужно сопоставить с [таблицей версий](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx) и определить человекопонятное имя.

В WinAPI действует ряд соглашений в именовании:

- функции именуются в UpperCamelCase, например, [GetVersion](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724834.aspx), [GetVersionEx](https://msdn.microsoft.com/en-us/library/ms724451.aspx). Сокращения используются в редких случаях, например, суффиксом "Ex" помечают расширенную версию более старой фукнции.
- имена типов данных именуются в верхнем регистре, часто с сокращениями: RECT, POINT, HMENU (handle to menu), OSVERSIONINFO (OS version information) и так далее
- для создания и удаления системных объектов, например, типа XYZ, предоставляются функции с именами вида "CreateXYZ" и "DestroyXYZ"
- многие привычные типы данных получили свои синонимы (в целях максимального контроля над стабильностью)
    - WORD &mdash; машинное слово, 16-битное целое без знака, аналог uint16_t
    - DWORD &mdash; удвоенное машинное слово, 32-битное целое без знака, аналог uint32_t
    - BOOL &mdash; синоним типа int, введённый по той причине, что в языке C89 нет типа bool. Тип `bool` появился в C++, а тип `_Bool` &mdash; в C99
    - LPCSTR &mdash; синоним `const char *`, расшифровывается как Left-Pointer to Const String, т.е. *изменяемый* (способный стоять в левой части присваивания) указатель на *неизменяемую* строку в стиле C, завершённую нулевым символом.
    - LPSTR &mdash; синоним `char *`, расшифровывается как Left-Pointer to String, т.е. *изменяемый* (способный стоять в левой части присваивания) указатель на *изменяемую* строку в стиле C, завершённую нулевым символом.
    - LPCWSTR &mdash; синоним `const wchar_t *`, расшифровывается как Left-Pointer Wide Const String, т.е. вместо типа char использует тип wide char, способный представлять символы одной из кодировок Unicode &mdash; UTF16

```cpp
// В современном WinAPI функция GetVersionEx считается устаревшей,
//   поэтому пример годится лишь для демонстрации WinAPI.
int main()
{
    // Заполняем структуру нулевыми байтами (специальный синтаксис C89).
    OSVERSIONINFO osVersion = { 0 };
    // WinAPI требует указывать размер структуры, чтобы иметь возможность
    //  расширять структуру в новых версиях ОС.
    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    const BOOL succeed = ::GetVersionEx(&osVersion);
    // Функция может вернуть FALSE только если параметр равен nullptr,
    //  либо в структуре неверное поле dwOSVersionInfoSize.
    assert(succeed);

    const unsigned majorVersion = osVersion.dwMajorVersion;
    const unsigned minorVersion = osVersion.dwMinorVersion;

    std::printf("Running under Windows %d.%d\n", majorVersion, minorVersion);
}
```

Вы могли заметить, что в предыдущих двух примерах используются устаревшие функции. Начиная с Windows 8, компания Microsoft решила объявить устаревшими [GetVersion](https://msdn.microsoft.com/en-us/library/ms724439.aspx) и [GetVersionEx](https://msdn.microsoft.com/en-us/library/ms724451.aspx), и они теперь могут возвращать неправильное значение согласно спецификации.

Вместо них предлагается использовать функции из заголовка [VersionHelpers.h](https://msdn.microsoft.com/en-us/library/dn424972.aspx). Эти функции не реализованы в библиотеках WinAPI и всего лишь дают фасад для вызова [VerifyVersionInfo](https://msdn.microsoft.com/en-us/library/windows/desktop/ms725492.aspx). Функции из состава VersionHelpers.h имеют более привычное именование версий ОС в сравнении с GetVersion и GetVersionEx.

```cpp
const char *GetOsVersionName()
{
    if (IsWindows8Point1OrGreater())
    {
        return "8.1";
    }
    if (IsWindows8OrGreater())
    {
        return "8";
    }
    if (IsWindows7OrGreater())
    {
        return "7";
    }
    if (IsWindowsVistaOrGreater())
    {
        return "Vista";
    }
    if (IsWindowsXPOrGreater())
    {
        return "XP";
    }
    return "Unknown";
}

void PrintVersion3rdWay()
{
    const char *osVersionName = GetOsVersionName();

    std::printf("Running under Windows %s\n", osVersionName);
}
```

<!-- TODO: UTF16 -->

## API для получения версии в Linux

## API для получения версии в MacOSX
