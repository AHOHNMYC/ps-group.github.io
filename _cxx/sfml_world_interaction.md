---
title: 'Как спроектировать мир и объекты в игре'
---

Игра — интерактивная система, в которой некоторые объекты подчиняются действиям игрока, другие — собственным решениям, третьи — статичны, и все взаимодействуют друг с другом. В этой статье мы рассмотрим, как организовать взаимодействие разных объектов в рамках обработки логики игры.

> Совет: пока вы пишете свою первую игру, предпочитайте простые, процедурные решения вместо более сложных, основанных на ООП или готовых библиотеках. Научиться правильно использовать конструкторы и деструкторы, исключения, инкапсуляцию и полиморфизм можно со временем, возможно, уже в следующем вашем проекте.

## Шаг 1: создать мир, который знает всё обо всех

```cpp
class World
{
    PlayerUnit player; // персонаж игрока
    std::vector<Enemy> enemies; // противники
    std::vector<Bonus> bonuses; // бонусы
    std::vector<Bullet> bullets; // пули и снаряды
};
```

Если класс/структура World стал слишком большим, вы можете выполнить рефакторинг:

-  выделить некоторые функции World в новые классы/структуры, может быть, даже в классы Enemy, Bonus и т.д. Например, принятием решения об атаке враги могут заниматься сами, если они смогут получить достаточно информации для решения.
-  сократить код за счёт использования универсальных функций и классов, таких как `double parseDouble(const std::string &str)`, `sf::Vector2f` и т.д. Например:

```cpp
//--------------------
// Плохой код, x и y зачем-то вычисляются отдельно
float x = radius * sin(angle);
float y = radius * cos(angle);
// метод sf::Sprite::setPosition имеет две перегрузки,
//  одна из них принимает x, y раздельно, вторая - в составе sf::Vector2f
sprite.setPosition(x, y);

//--------------------
// Хороший код, вместо разделения x и y мы используем sf::Vector2f
const sf::Vector2f position = radius * sf::Vector2f(sic(angle), cos(angle));
sprite.setPosition(position);

//--------------------
// Отличный код, мы нашли возможность использовать универсальную функцию,
//  выполняющую перевод из полярных координат в декартовы
sf::Vector2f FromPolarCoords(float radius, float angle)
{
    return radius * sf::Vector2f(sic(angle), cos(angle));
}

sprite.setPosition(FromPolarCoords(radius, angle));
```

## Шаг 2: запрограммировать в мире симуляции взаимодействия

У нас есть несколько категорий объектов (как минимум — игрок, враг, бонус, пуля). Взаимодействие каждого с каждым подчиняется теореме о рукопожатиях, т.е. максимальное число типов взаимодействий равно `N * (N - 1) / 2`, где N — количество категорий. Однако, реально типов гораздо меньше:

- пуля не может взаимодействовать с пулей, если только это не является особенностью механики
- бонусы статичны и не взаимодействуют с другими бонусами
- враги, скорее всего, не взаимодействуют друг с другом, за исключением простого запрета прохождения друг сквозь друга

В рамках подхода Game Loop вы можете запрограммировать симуляцию очередной итерации физики и логики мира в процедуре update:

```cpp
void World::update(float elapsedSeconds)
{
    // 1. AI принимает решения, возможно, стреляет
    // 2. происходит перемещение игрока, врагов и пуль на новые позиции,
    //    обрабатываются столкновения со статическими объектами
    // 3. проверка пересечения игрока и пули
    // 4. проверка пересечения врага и пули
    // 5. проверка пересечения игрока и бонуса
    // 6. выполнение покадровых анимаций и тому подобного
}
```

## Шаг 3: Собираем павших

Если мы хотим уничтожить игровую сущность, то, возможно, не стоит делать этого в цикле. В примере ниже показана недопустимая реализация обхода цикла, поскольку объект типа `iterator` становится невалидным после любого изменения контейнера, к которому он относится, поскольку при любом изменении может произойти перераспеделение памяти и сдвиг элементов:

```cpp
// ОЧЕНЬ ПЛОХОЙ КОД
for (std::vector<Bonus>::iterator it = bonuses.begin(); it != bonuses.end(); ++it)
{
    it->move();
    if (HaveIntersection(*it, player))
    {
        bonuses.erase(it);
    }
}
```

Исправить приведённый выше пример можно, сохранив результат вызова `erase` в переменную it, поскольку по спецификации стандартной библиотеки C++ метод `vector::erase` возвращает новый итератор, находящийся после удалённого, и устойчив к перераспределению памяти в структуре данных. Ещё лучше будет использовать идиому "remove_if/erase", полностью избавив этот участок кода от цикла "for".

Можно также не удалять бонусы и другие сущности сразу, а завести в них специальный флаг `bool alive`, который будет равен true с начала жизни объекта и до его смерти в игре. В конце метода обновления мы можем собрать все объекты, у которых флаг `alive` выставлен в false, с помощью той же идиомы "remove_if/erase".

## Обеспечить информацией для принятия решения

```cpp
// Направление движения (предположим, в механике игры разрешено лишь 4 направления)
enum class Direction
{
    Up,
    Down,
    Left,
    Right,
};

class CWorld
{
public:
    Direction FindPathBetweenPoints() = 0;
};

// Способ первый: передача в конструктор
class Bonus
{
public:
    // значение поля задаётся  в списках инициализации конструктора
    //  (англ. constructor initializer lists)
    Bonus(IWorld &world)
        : m_world(world)
    {
    }

private:
    IWorld &m_world;
}
```
