---
title: 'Массивы в C++'
subtitle: 'В этой статье вы научитесь работать с массивами: объявлять, инициализировать и получать доступ к элементам'
screenshot: 'img/arrays/Arrays-C++.jpg'
---

>Вы читаете вольный перевод статьи [C++ Arrays (programiz.com)](https://www.programiz.com/cpp-programming/arrays)

В программировании часто встречается задача обработки множества экземпляров однотипных данных. Представьте себе ситуацию: мы провели опрос 100 человек и узнали их возраст. Чтобы сохранить собранные данные, вы можете создать целочисленный массив, содержащий 100 элементов:

```cpp
// массив из 100 целых чисел
int ages[100];

// массив из 100 целых неотрицательных чисел
unsigned ages[100];

// массив из 20 чисел с плавающей точкой
// (вы можете использовать константу, известную при компиляции)
constexpr unsigned ARRAY_SIZE = 20;
float rotations[ARRAY_SIZE];

// общий синтаксис
DataType variableName[ARRAY_SIZE];
```

В C++ массивы статичны: вы не сможете изменить размер или тип элементов после объявления.

## Доступ к элементам массива

Вы можете получать доступ к элементам массива, используя индексы и оператор `[]`. Допустим, вы объявили массив `marks`, как показано ниже. К первому элементу можно обратиться выражением `marks[0]`, ко второму - выражением `marks[1]`, и так далее. Доступ всегда начинается с единицы, а индекс последнего элемента на единицу меньше размера массива.

```cpp
void example()
{
    // Объявляем массив оценок
    int marks[5];
    // Заполняем массив по элементам.
    marks[0] = 19;
    marks[1] = 10;
    marks[2] = 8;
    marks[3] = 17;
    marks[4] = 9;
}
```

![Иллюстрация](img/arrays/c-array-declaration.png)

## Инициализация массива при объявлении

Можно инициализировать массив при объявлении. Для этого надо указать в списке столько значений, сколько вмещает массив, либо одно значение 0, чтобы заполнить массив нулями:

```cpp
// Объявляем массив размера 5 и инициализируем.
int marks[5] = { 19, 10, 8, 17, 9 };

// Объявляем массив без указания размера,
//  размер будет определён из списка инициализациии.
int marks[] = { 19, 10, 8, 17, 9 };

// Объявляем массив размера 10 и заполняем нулями.
int ages[10] = { 0 };
```

## Обход элементов массива в цикле

Узнать число элементов в массиве можно функцией [std::size](http://en.cppreference.com/w/cpp/iterator/size). Обойти можно, используя цикл по индексам либо range-based for:

```cpp
void example()
{
    int ages[] = { 17, 18, 29, 30, 16, 27, 22 };

    // цикл по индексам массива,
    //  специальный тип size_t - это беззнаковое целое,
    //  разрядность которого совпадает с разрядностью платформы
    //  (4 байта на 32-битных машинах и 8 байт на 64 битных)
    for (size_t i = 0; i < std::size(ages); ++i)
    {
        const int age = ages[i];
        std::cout << "age #" << i << " is " << age << std::endl;
    }

    // цикл по всем элементам массива,
    //  эта конструкция известна как range-based for.
    int agesSum = 0;
    for (int age : ages)
    {
        agesSum += age;
    }
    std::cout << "ages sum is " << agesSum << std::endl;

    // ещё одна фишка: цикл в стиле итераторов
    auto end = std::end(ages);
    int minAge = ages[0];
    for (auto it = std::begin(ages), it != end; ++it)
    {
        // если этот элемент меньше минимального, обновляем минимальный возраст.
        if (age < minAge)
        {
            minAge = age;
        }
    }
    std::cout << "smallest age is " << minAge << std::endl;
}
```

## Неопределённое поведение: выход за границы (out of bounds)

Выход за пределы массива является неопределённым поведением. Нет гарантий, как поведёт себя программа в этом случае. Высока вероятность, что вы испортите память других переменных, но эффект может различаться в разных режимах компиляции:

```cpp
#include <iostream>

int main()
{
	// Индексы элементов: 0, 1, 2
	int ages[] = {1, 2, 3};

	// Неопределённое поведение! Запрос элемента с индексом 3 в массиве,
	//  где такого индекса нет.
	std::cout << ages[3] << std::cout;
}
```
