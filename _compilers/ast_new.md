# AST в компиляторе

## Зачем нужен AST?

AST - это Abstract Syntax Tree, то есть дерево, которое в абстрактном виде представляет структуру программы.

AST создаётся парсером по мере синтаксического разбора программы. В современных компиляторах AST и список диагностик (ошибок, предупреждений) - это два результата вызова модуля разбора (или функции разбора).

AST содержит полную синтаксическую модель программы без лишних деталей (таких, как пробельные символы или комментарии). Чтобы понять, как это работает, рассмотрим, из чего состоит типичный язык программирования.

Типовой императивный язык программирования (такой как C, C++, PASCAL, Java, JavaScript, C#) состоит из трёх синтаксических элементов:

* Выражения (expressions)
* Инструкции (statements)
* Объявления (declarations)

AST создаётся парсером по мере синтаксического разбора программы. В современных компиляторах AST и список диагностик (ошибок, предупреждений) - это два результата вызова модуля разбора (или функции разбора).

### Выражения

Выражения - это выражение формулы в исходном коде. Выражение может иметь побочные эффекты: например, при вызове функции внутри выражения функция может что-то напечатать. В типичном языке программирования есть как минимум следующие типы выражений:

* Доступ к переменной (variable access): например, `x`
* Литерал (literal): например, `5.18` или `"some meaningful string"`
* Унарный оператор (unary operator): например, `-x`
* Бинарный оператор (binary operator): например, `x + 5.18` или `x == 5.18`
    * Разные бинарные операторы обычно имеют разный приоритет и могут группироваться скобками, но в функциональных языках (LISP, Haskell) операторы бывают неотличимы от функций
    * Типовой набор операторов: арифметические, логические, сравнения; такой набор уже позволяет создавать полноценные программы
* Вызов функции (function call): например, `sqrt(pow(a, 2.0) + pow(b, 2.0))`

### Инструкции

Инструкции - это действия в исходном коде. Инструкция всегда имеет побочный эффект (печать, присваивание переменной, смена потока управления и т.д.), поэтому в некоторых языках инструкций не существует - например, в LISP или Haskell.

Примеры инструкций, характерных для процедурных языков:

* Объявление переменной с опциональной/обязательной инициализацией, например, `let value = ...;` или `int x = 500;`
** В языке Python объявлений переменных нет
* Присвоение переменной, например, `velocity = velocity + acceleration * dt;`
* Специальные инструкции, например, печать `print x+1` или проверка контракта `assert isinstance(x, int)` в языке Python
* Условные инструкции, такие как `if`, `switch`
* Циклы, такие как `while`, `do/while`, `repeat/until`, `for`, `foreach`
* Инструкции потока управления, например, возвраты из функций `return x+5;` или прерывания циклов `break;`
** Возвраты требуются не во всех языках - иногда функция просто возвращает последнее вычисленное выражение
* Блоки кода, такие как `{ doA(); doB(); return 5; }`

### Объявление

Объявление - это создание новой именованной сущности, такой как функция или тип. Объявления типов бывают разнообразными: различные языки могут позволять объявлять новый тип как синоним старого типа, как структуру, как класс, как интерфейс или иным образом.

### Спорные вопросы

Некоторые сущности трудно отнести к той или иной категории. Например:

* Объявление анонимной функции (лямбды) можно считать объявлением без имени либо выражением
* Объявление переменной можно считать как просто инструкцией, так и полноценным объявлением

Спорные вопросы обычно решаются в сторону удобства для создателя языка или компилятора.

## Что такое AST?

AST - это Abstract Syntax Tree, т.е. представление структуры программы в виде дерева объявлений, инструкций и выражений.

* AST не является бинарным деревом: например, у унарного оператора будет один дочерний узел
* AST является гетерогенным деревом, состоящим из узлов разного типа
** В этом AST похож на DOM-представление документа HTML/XML
* В каждом поддереве дочерними узлами становятся лексически вложенные сущности: например, для узла объявления функции дочерними узлами являются инструкции, составляющие тело функции, а также объявления параметров функции (если они выделены в отдельные узлы AST волей автора компилятора)

Удобный способ реализовать AST в коде - это иерархия классов и интерфейсов. Например, можно ввести три базовых интерфейса:

* `ExpressionAST` - интерфейс, который реализуется всеми выражениями
* `StatementAST` - интерфейс, который реализуется всеми инструкциями
* `DeclarationAST` - аналогичный интерфейс для объявлений функций и типов
** В компилируемых языках всю программу целиком можно считать списком `DeclarationAST`, в скриптовых - списком `StatementAST`
** Альтернативно, можно ввести специальный узел `ProgramAST` или `ModuleAST`

Если в языке нет типов, то `DeclarationAST` можно для удобства превратить в `FunctionAST` и считать программу списоком `FunctionAST`.

Все остальные классы из иерархии наследуются от базовых интерфейсов и реализуют объявленные ими методы. Какие методы находятся в базовых интерфейсах - решать автору компилятора/интерпретатора. В любом случае, методы должны выстраиваться в единую модель генерации кода или интерпретации.

Суть дерева - в возможности обойти его (слева направо вглубину или другим способом). При обходе можно выполнять осмысленные действия, при этом возникает *проблема двойной диспетчеризации*: мы должны выбирать действие в зависимости как от алгоритма, которым мы обрабатываем дерево, так и от типа узла дерева, который мы сейчас обходим. Рассмотрим пути решения проблемы:

* Можно избежать проблемы: например, добавляем полиморфный метод `Evaluate` в интерфейс `ExpressionAST` и реализуем его по-разному в классах `LiteralAST`, `VariableAST`, `BinaryOperatorAST`, `CallAST` - на выходе получаем возможность вычислить выражение
* Можно решить проблему с помощью шаблона проектирования Visitor (Посетитель)
* Можно решить проблему с помощью сопоставления шаблона (pattern matching) по типу, если язык это поддерживает
** Например, в `Go` можно использовать [type switch](https://yourbasic.org/golang/type-assertion-switch/)
** В C++ можно было бы использовать `std::variant`, но он не поддерживает рекурсию в собственном определении

## Конструирование AST

Для констурирования узлов AST потребуется выделять память, а затем запоминать указатель в стеке парсера. Напомним, что любой реальный язык содержит рекурсивные синтаксические правила (например, выражения всегда определяются рекурсивно), значит, парсер языка не может быть реализован без стека или без рекурсии (которая эквивалентна стеку). Поэтому способ работы с AST зависит от метода создания парсера



### От парсера к AST

* Если вы используете рекурсивный спуск, то вы запоминаете новые узлы AST в локальные переменные
*

## Прямая интерпретация AST

Пример адекватной модели в псевдокоде:

```cpp
interface ExpressionAST
{
}
```

## Области видимости

## Интерпретация AST на виртуальной машине

## Кодогенерация с AST
