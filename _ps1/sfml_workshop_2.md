---
title: 'Массовые столкновения'
subtitle: 'На этом занятии вы научитесь программировать игры уровня Бильярда или Арканоида, а также сталкивать между собой прямоугольники и круги'
preview: 'img/preview/sfml_workshop_2.png'
---

Выполните задания, соблюдая [стиль кодирования](cxx_coding_style). Готовые задания должны быть выложены на гитхаб.

## Задание workshop2.1

Напишите программу, в которой несколько разноцветных шаров летают в пределах окна, отталкиваясь от стенок

- шарам не нужно сталкиваться между собой
- цвета и начальные скорости шаров задаются прямо в коде без какого-либо механизма случайностей
- для выполнения задания вы можете использовать массив либо `std::vector`
- скорость и CircleShape шара лучше поместить в структуру, и использовать массив структур

Перед выполнением задачи изучите статью [Массивы в C++](/cxx/cxx_arrays). Вы можете использовать инициализацию массива при объявлении, чтобы сделать код более аккуратным и читаемым.

![Иллюстрация](img/labor/multiple_balls.png)

## Задание workshop2.2 (до 2 баллов)

Добавьте шарам возможность отталкиваться друг от друга.

Для обнаружения столкновений достаточно сравнить все возможные пары шаров: если расстояние между центрами меньше суммы радиусов, шары сталкиваются. Перебрать каждую пару объектов ровно один раз можно с помощью вложенного цикла:

```cpp
constexpr size_t SIZE = 100;
Ball balls[SIZE];

// Перебираем каждую пару объектов
//  - ни одну пару не используем дважды
//  - не используем пары из одного объекта (т.е. объект не сталкивается сам с собой)
for (size_t fi = 0; fi < SIZE; ++fi)
{
	for (size_t si = fi + 1; si < SIZE; ++si)
	{
		// проверяем столкновение fi, si
	}
}
```

Такой цикл среди всех возможных сочетаний элементов переберёт только пары разных элементов, и ни одну пару не переберёт дважды:

![Иллюстрация](img/labor/for-each-pair.png)

При расчёте скоростей после удара важны скорости шаров до удара и взаимное положение их центров (при условии, что массы шаров равны). Это проиллюстрировано рисунке:

![Иллюстрация](img/labor/balls_collision.gif)

Считайте, что шары имеют одинаковую массу, а столкновение абсолютно упругое. В этом случае скорости шаров после удара вычисляются так, как показано на схеме:

![Схема](img/labor/balls_collision.png)

## Задание workshop2.3

Перед выполнением задачи изучите статью [Генерация случайных чисел в Modern C++](/cxx/cxx_random).

Добавьте случайную генерацию скоростей для шаров. Скорости не должны быть слишком большими или слишком маленькими: при генерации случайных чисел надо задать разумные ограничения.

## Задание workshop2.4 (дополнительное, до 2 баллов)

Изучите документацию класса [sf::Color](https://www.sfml-dev.org/documentation/2.4.2/classsf_1_1Color.php).

Затем добавьте случайную генерацию цвета шаров. Выбирать случайный цвет можно, например, следующим методом:

 1. Создать массив предопределённых значений типа sf::Color (достаточно 8 цветов на ваш вкус), этот массив будет служить палитрой
 2. Реализовать случайную генерацию индекса в этом массиве
 3. Получив случайный индекс, запросить из палитры цвет с этим индексом

>Составить хорошую палитру поможет сайт [websafecolors.info](http://websafecolors.info/).

Задание оценивается вполовину, если вы лишь берёте цвет из палитры. Для получения полных баллов надо повысить случайность цвета:

- выбирать два случайных индекса вместо одного
- полученные из палитры два цвета комбинировать путём вычисления среднего арифметического их RGBA-значений

## Задание workshop2.5 (дополнительное, до 2 баллов)

Добавьте возможность создавать шар со случайным цветом и скоростью по клику левой кнопкой мыши.

- шар не должен создаваться, если после создания он бы сразу пересёкся с другим шаром (другими словами, нельзя создать шар над другим шаром)
- для хранения динамического массива шаров вам не подойдёт массив в стиле `Ball balls[...]`, используйте `std::vector`

## Задание workshop2.6 (дополнительное, до 2 баллов)

Добавьте шарикам время жизни: каждый шар после создания существует ровно 10 секунд, после чего исчезает.

- счётчик оставшегося времени жизни лучше держать в структуре Ball
- удаление отживших своё элементов массива шаров можно выполнять с помощью идиомы `remove_if + erase`; изучите, как эта идиома реализуется в C++, и используйте её
- удаление отживших своё элементов удобнее выделить в функцию removeDeathBalls, обновление времени жизни всех шаров удобно выделить в функцию updateBallLifetimes

>Если вы допускаете существенные ошибки в реализации `remove_if + erase`, то задание оценивается вполовину
