---
title:  Основной цикл программы
subtitle: В статье мы освоим паттерн Game Loop, а также научимся обрабатывать события мыши и клавиатуры.
draft: true
---

Создайте каталог с названием `sfml.2`. Откройте каталог в Visual Studio Code. Откройте терминал и убедитесь, что вы находитесь в этом каталоге:

![Скриншот](img/ui/vscode_in_sfml2.png)

Все упражнения и задания вы будете выполнять в подкаталогах каталога `sfml.2`: `sfml.2\00`, `sfml.2\01` и так далее.

Следуйте инструкциям. Также выполните задания, указанные в тексте. Если при компиляции у вас возникнут ошибки, внимательно читайте текст ошибок в терминале.

## Игра Fizz-Buzz и цикл while

Когда американские дети изучают числа, они играют в игру Fizz-Buzz:

- ведущий считает от 1 до 100
- когда называют число, кратное трём, дети должны сказать "Fizz"
- если названо число, кратное 5, дети должны сказать "Buzz"
- если число кратно и 3, и 5, надо сказать "FizzBuzz"
- иначе надо назвать число

Давайте напишем программу, которая играет в FizzBuzz сама с собой!

Создайте в каталоге `sfml.2` файл `CMakeLists.txt`, перепишите в него текст:

```cmake
# Минимальная версия CMake: 3.8
cmake_minimum_required(VERSION 3.8 FATAL_ERROR)

# Имя проекта: sfml-lab-2
project(sfml-lab-2)

# Подкаталог 00 содержит ещё один CMakeLists.txt
add_subdirectory(00)
```

Создайте подкаталог `00` в каталоге `sfml.2`. В подкаталоге создайте ещё один файл `CMakeLists.txt`, и скопируйте в него текст:

```cmake
# Добавляем исполняемый файл 00
# Он собирается из 1 файла исходного кода: main.cpp
add_executable(00 main.cpp)
```

Сейчас каталог должен выглядеть так:

![Скриншот](img/ui/vscode_in_sfml2v2.png)

Затем создайте файл `main.cpp` и опишите в нём псевдокод:

```cpp
#include <iostream>

int main()
{
	// в цикле от 1 до 100
	//  - если число кратно и 3, и 5, вывести FizzBuzz
	//  - иначе если число кратно 3, вывести Fizz
	//  - иначе если число кратно 5, вывести Buzz
	//  - иначе вывести число
}
```

Теперь мы будем раскрывать псевдокод шаг за шагом. Снала разберёмся с циклами, которые в C++ представлены ключевыми словами `while` и `for`. Синтаксис:

```cpp
// цикл, пока выполняется условие
// тело - это одна инструкция или блок
while (условие) инструкция;

// цикл с блоком инструкций
while (условие)
{
	инструкция_1;
	инструкция_2;
}

// цикл выводит числа от 1 до 100
int num = 1;
// условие: пока num меньше или равно 100
while (num <= 100)
{
	std::cout << num << std::endl;
	// добавляем к числу 1
	// оператор += это сокращение от `num = num + 1`
	num += 1;
}
```

Последний цикл перепишите в main вместо комментария "в цикле от 1 до 100", а остальные комментарии пока поместите в тело цикла:

![Код](img/code/fizzbuzz_0.1.png)

Соберите программу с помощью следующих команд:

```cpp
cmake -G "MinGW Makefiles"
cmake --build .
```

Если сборка прошла успешно и ошибок не было, запустите программу. Она должна просто вывести числа от 1 до 100 включительно.

## Цикл for

Цикл for имеет две формы: классическая и range-based. Мы рассмотрим классическую:

```cpp
for (начальное_действие; условие; действие_в_конце_итерации)
    инструкция_или_блок

// начальное действие: объявить переменную num, равную 1
// условие: пока num меньше или равно 100
// после каждого шага (итерации) цикла добавляем к num единицу
for (int num = 1; num <= 100; num += 1)
{
	// выводим num
	std::cout << num << std::endl;
}
```

Вернитесь к `main.cpp` и замените цикл while на цикл for:

![Код](img/code/fizzbuzz_0.2.png)

Соберите программу командой `cmake --build .` (не забудьте про точку в конце команды). Если программа собралась успешно и ошибок не было, запустите программу командой `00\00`. Она должна снова вывести числа от 1 до 100 включительно.

## Деление с остатком и инструкция if

Чтобы определить делимость, мы воспользуемся делением с остатком. Эта одна из 5 арифметических операций в C++:

- `16 + 3 == 19`, `16 - 3 == 13` — сложение и вычитание чисел
- `16 * 3 = 48`, `16 / 3 = 5` — умножение и деление чисел (при делении целых чисел остаток отбрасывается)
- `16 % 3 == 1` — получение остатка от деления, также называют "взять модуль числа 16 по числу 3"

Для условного выполнения печати мы применим инструкцию if/else. Её синтаксис:

```cpp
if (условие)
    инструкция_или_блок
else
    инструкция_или_блок

// пример: если число меньше 10, печатаем его
if (num < 10)
{
    std::cout << num << std::endl;
}
```

Цепочку инструкций else мы объединим, записывая `.. else if ..` в одной строке. В первом варианте код будет выглядеть так:

![Код](img/code/fizzbuzz_0.3.png)

Перепишите код в "main.cpp", затем соберите командой `cmake --build .` (не забывайте точку в конце), и запустите программу "00\00". Обратите внимание на вывод районе чисел 12..17:

```
Fizz
13
14
Fizz
16
17
```

К сожалению, вывод программы неправилен: для числа 15 надо вывести "FizzBuzz", а выведено "Fizz". Мы исправим это дополнительным условием: если число кратно и 3, и 5, то выведем "FizzBuzz". Воспользуемся логическими операциями в C++:

- `a || b` — логическое ИЛИ, истинно если хотя бы одно из двух условий "a" и "b" истинно
- `a && b` — логическое И, истинно только если оба условия "a" и "b" истинны

>Есть другой способ: число, которое делится на 3 и на 5, делится на 15, и наоборот. Но мы будем использовать операцию "логическое И" в целях тренировки.

Доработайте код следующим образом:

![Код](img/code/fizzbuzz_1.0.png)

Перепишите код в "main.cpp", затем соберите командой `cmake --build .` (не забывайте точку в конце), и запустите программу "00\00". Теперь программа должна работать правильно для всех чисел 1..100.

## Цикл рисования и обработки событий

В любой операционной системе оконные приложения рисуют содержимое окон непрерывно и циклически. В каждую секунду в системе проиходит множество событий:

- мониторы обновляются с частотой ~60 Герц (60 кадров в секунду)
- контроллер мыши присылает уведомления об изменении положения мыши
- контроллер клавиатуры присылает состояние клавиш
- каждая программа старается получить процессорное время, чтобы выполнить свои задачи

В таких условиях операционной системе приходится ловко манипулировать множеством событий и потоков данных. Например, 60 раз в секунду система собирает изображения всех окон, рисует их поверх друг друга в одну картинку рабочего стола и выводит на экран.

